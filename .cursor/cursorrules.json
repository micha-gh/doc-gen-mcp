{
  "name": "doc-gen-mcp Cursorrules",
  "version": "1.0.4",
  "description": "Cursor rules for the doc-gen-mcp documentation generator",
  "author": "doc-gen-mcp Team",
  "project": "doc-gen-mcp",
  "repository": "https://github.com/micha-gh/doc-gen-mcp",
  "readme": "# Cursor Rules für doc-gen-mcp\n\nDiese Datei enthält Regeln für die Entwicklung im doc-gen-mcp Projekt mit der Cursor IDE.\n\n## Verwendung\n\n1. Die Regeln werden automatisch in Cursor geladen, wenn das Projekt geöffnet wird\n2. Regeln sind nach Kategorien geordnet und haben verschiedene Schweregrade (error, warning, info)\n3. Jede Regel hat ein Beispiel zur korrekten Implementierung\n\n## Kategorien\n\n- **Exporter Implementation**: Regeln für die Implementierung von Exporter-Plugins\n- **Documentation**: Regeln zur Dokumentation und Kommentierung\n- **Code Style**: Regeln zum Coding-Style und Best Practices\n- **Testing**: Regeln für Tests und Test-Coverage\n- **Project Management**: Regeln für Projektdokumentation und -verwaltung\n- **Best Practices**: Best Practices für die Implementierung von Exportern\n\n## Schweregrade\n\n- **error**: Muss behoben werden\n- **warning**: Sollte behoben werden\n- **info**: Empfehlung zur Verbesserung",
  "categories": [
    {
      "name": "Exporter Implementation",
      "description": "Regeln für die Implementierung von Exporter-Plugins"
    },
    {
      "name": "Documentation",
      "description": "Regeln zur Dokumentation und Kommentierung"
    },
    {
      "name": "Code Style",
      "description": "Regeln zum Coding-Style und Best Practices"
    },
    {
      "name": "Testing",
      "description": "Regeln für Tests und Test-Coverage"
    },
    {
      "name": "Project Management",
      "description": "Regeln für Projektdokumentation und -verwaltung"
    },
    {
      "name": "Best Practices",
      "description": "Best Practices für die Implementierung von Exportern und die Projektstruktur"
    }
  ],
  "rules": [
    {
      "category": "Exporter Implementation",
      "name": "Exporter Plugin Implementation",
      "pattern": "class \\w+Exporter extends BaseExporter",
      "description": "Exporter plugins müssen von BaseExporter erben und die Standardmethoden implementieren: isConfigured, export, loadConfig, und validateContent.",
      "severity": "error",
      "example": "class MarkdownExporter extends BaseExporter { ... }",
      "requiresImplementation": [
        "isConfigured(): Promise<boolean>",
        "export(content: ExportContent, options?: ExportOptions): Promise<ExportResult>",
        "loadConfig(configPath?: string): Promise<any>",
        "validateContent(content: ExportContent): Promise<{valid: boolean; issues?: Array<{message: string; severity: string}>;}>",
        "name: string",
        "description: string",
        "supportedFormats: string[]",
        "defaultConfigPath: string"
      ]
    },
    {
      "category": "Exporter Implementation",
      "name": "Exporter Plugin Configuration",
      "pattern": "(/config/\\w+\\.json)",
      "description": "Jeder Exporter sollte eine zugehörige Konfigurationsdatei im config-Verzeichnis haben.",
      "severity": "warning",
      "example": "/config/markdown-exporter.json"
    },
    {
      "category": "Exporter Implementation",
      "name": "Export Content Validation",
      "pattern": "validateContent\\(content: ExportContent\\):",
      "description": "Die Validierungsmethode sollte die Inhalte auf erforderliche Felder überprüfen und entsprechende Fehlermeldungen zurückgeben.",
      "severity": "error",
      "example": "validateContent(content: ExportContent): Promise<{valid: boolean; issues?: Array<{message: string; severity: string}>;}> { ... }"
    },
    {
      "category": "Exporter Implementation",
      "name": "Plugin Registration",
      "pattern": "registerExporter\\(",
      "description": "Exporter-Plugins müssen beim ExporterManager registriert werden, um im System verwendet zu werden.",
      "severity": "error",
      "example": "exporterManager.registerExporter(new MarkdownExporter());"
    },
    {
      "category": "Exporter Implementation",
      "name": "Config Path Resolution",
      "pattern": "path\\.resolve\\(process\\.cwd\\(\\), 'config'",
      "description": "Konfigurationspfade sollten relativ zum Projektverzeichnis aufgelöst werden.",
      "severity": "warning",
      "example": "const configPath = path.resolve(process.cwd(), 'config', 'exporter.json');"
    },
    {
      "category": "Exporter Implementation",
      "name": "Exporter Naming Conventions",
      "pattern": "class (\\w+)Exporter",
      "description": "Exporter-Klassen sollten nach dem Schema '[Format]Exporter' benannt werden (z.B. MarkdownExporter, HTMLExporter).",
      "severity": "warning",
      "example": "class PDFExporter extends BaseExporter { ... }"
    },
    {
      "category": "Exporter Implementation",
      "name": "Format Support Declaration",
      "pattern": "supportedFormats\\s*=\\s*\\[",
      "description": "Exporter sollten explizit ihre unterstützten Formate deklarieren.",
      "severity": "error",
      "example": "supportedFormats = ['markdown', 'md'];"
    },
    {
      "category": "Documentation",
      "name": "Exporter Documentation",
      "pattern": "(/docs/\\w+-exporter-usage\\.md)",
      "description": "Jeder Exporter sollte eine Dokumentation im docs-Verzeichnis haben, die seine Verwendung erklärt.",
      "severity": "info",
      "example": "/docs/markdown-exporter-usage.md"
    },
    {
      "category": "Documentation",
      "name": "Method Documentation",
      "pattern": "/\\*\\*[\\s\\S]*?\\*/",
      "description": "Öffentliche Methoden sollten mit JSDoc-Kommentaren dokumentiert sein.",
      "severity": "warning",
      "example": "/**\n * Exportiert Inhalte in das Markdown-Format\n * @param {ExportContent} content - Der zu exportierende Inhalt\n * @returns {Promise<ExportResult>} Das Ergebnis des Exports\n */"
    },
    {
      "category": "Documentation",
      "name": "Markdown Formatting",
      "pattern": "(##+)\\s+([\\w\\s]+)",
      "description": "Markdown-Dateien sollten eine konsistente Überschriftenstruktur verwenden.",
      "severity": "info",
      "example": "## Überschrift Ebene 2\n### Unterabschnitt"
    },
    {
      "category": "Documentation",
      "name": "CLI Command Documentation",
      "pattern": "--[\\w-]+",
      "description": "CLI-Kommandos sollten konsistent formatiert sein und in der Dokumentation erklärt werden.",
      "severity": "warning",
      "example": "--export-format=markdown"
    },
    {
      "category": "Documentation",
      "name": "Documentation Generation",
      "pattern": "generateDocsFrom\\w+",
      "description": "Dokumentations-Generierungsfunktionen sollten strukturierte Daten akzeptieren und Validierung durchführen.",
      "severity": "warning",
      "example": "generateDocsFromSchema(schema, options)"
    },
    {
      "category": "Code Style",
      "name": "TypeScript Type Definitions",
      "pattern": "interface \\w+",
      "description": "Komplexe Datenstrukturen sollten als TypeScript-Interfaces definiert werden.",
      "severity": "warning",
      "example": "interface ExportOptions {\n  outputPath: string;\n  format: string;\n}"
    },
    {
      "category": "Code Style",
      "name": "Error Handling",
      "pattern": "try {[\\s\\S]*?} catch \\(err\\) {",
      "description": "Operationen sollten in try-catch-Blöcken durchgeführt werden, um Fehler zu behandeln und sinnvolle Fehlermeldungen zurückzugeben.",
      "severity": "warning",
      "example": "try {\n  await exporter.export(content);\n} catch (err) {\n  console.error('Export fehlgeschlagen:', err.message);\n}"
    },
    {
      "category": "Code Style",
      "name": "ESM Module Import",
      "pattern": "import {[^}]*} from '[^']+\\.js';",
      "description": "Imports sollten die .js-Erweiterung beibehalten, auch wenn die Dateien TypeScript sind, da das Projekt ESM Module verwendet.",
      "severity": "error",
      "example": "import { BaseExporter } from '../core/base-exporter.js';"
    },
    {
      "category": "Code Style",
      "name": "Async/Await Pattern",
      "pattern": "async [\\w\\s]+\\([^)]*\\)\\s*{",
      "description": "Asynchrone Funktionen sollten das async/await Pattern verwenden, statt Promise-Chains.",
      "severity": "warning",
      "example": "async export(content: ExportContent): Promise<ExportResult> {\n  const result = await this.transform(content);\n  return result;\n}"
    },
    {
      "category": "Code Style",
      "name": "Destructuring Assignment",
      "pattern": "const {[^}]*} = ",
      "description": "Verwende Destructuring für bessere Lesbarkeit beim Zugriff auf Objekteigenschaften.",
      "severity": "info",
      "example": "const { title, sections, metadata } = content;"
    },
    {
      "category": "Testing",
      "name": "Test Coverage for Exporters",
      "pattern": "(/test/exporters/\\w+\\.test\\.mjs)",
      "description": "Jeder Exporter sollte entsprechende Tests im test/exporters Verzeichnis haben.",
      "severity": "warning",
      "example": "/test/exporters/markdown-exporter.test.mjs"
    },
    {
      "category": "Testing",
      "name": "Test Mocking",
      "pattern": "jest\\.mock\\(",
      "description": "Tests sollten externe Abhängigkeiten mocken, um keine realen externen Ressourcen zu nutzen.",
      "severity": "info",
      "example": "jest.mock('fs', () => ({\n  promises: {\n    writeFile: jest.fn().mockResolvedValue(undefined)\n  }\n}));"
    },
    {
      "category": "Testing",
      "name": "Test Assertions",
      "pattern": "expect\\([^)]+\\)\\.(to|not)\\.",
      "description": "Tests sollten klare Assertions verwenden, um erwartetes Verhalten zu überprüfen.",
      "severity": "warning",
      "example": "expect(result.success).toBe(true);"
    },
    {
      "category": "Project Management",
      "name": "CHANGELOG Updates",
      "pattern": "## \\[Unreleased\\]",
      "description": "Bei Hinzufügen neuer Features oder Bugfixes sollte der CHANGELOG unter [Unreleased] aktualisiert werden.",
      "severity": "info",
      "example": "## [Unreleased]\n- Hinzufügen des Markdown-Exporters mit Unterstützung für Tabellen und Codeblöcke"
    },
    {
      "category": "Project Management",
      "name": "Roadmap Updates",
      "pattern": "Implementation Roadmap",
      "description": "Bei Abschluss von Features sollte diese in der Implementation Roadmap als abgeschlossen markiert werden.",
      "severity": "info",
      "example": "- [x] Implementierung des HTML-Exporters mit Template-Unterstützung"
    },
    {
      "category": "Best Practices",
      "name": "Template Configuration",
      "pattern": "(template|templates):\\s*\\{",
      "description": "Für Exporter, die Templates unterstützen, sollten Konfigurationsoptionen für Templates angeboten werden.",
      "severity": "info",
      "example": "templates: {\n  default: './templates/default.hbs',\n  custom: './templates/custom.hbs'\n}"
    },
    {
      "category": "Best Practices",
      "name": "Locale Support",
      "pattern": "(locale|language):\\s*['\"](\\w+)['\"]",
      "description": "Exporter sollten Unterstützung für verschiedene Sprachen anbieten, wo es sinnvoll ist.",
      "severity": "info",
      "example": "locale: 'de-DE'"
    },
    {
      "category": "Best Practices",
      "name": "Filesystem Operations",
      "pattern": "fs\\.(write|read)",
      "description": "Bei Dateisystemoperationen sollte immer die Promise-basierte API verwendet werden.",
      "severity": "warning",
      "example": "await fs.promises.writeFile(outputPath, content);"
    },
    {
      "category": "Best Practices",
      "name": "Performance Considerations",
      "pattern": "for\\s*\\([^)]+\\)\\s*\\{",
      "description": "Bei großen Datenmengen sollten performante Methoden wie map/reduce statt Schleifen verwendet werden.",
      "severity": "info",
      "example": "const transformedSections = sections.map(section => transformSection(section));"
    }
  ],
  "ignorePatterns": [
    "node_modules/",
    "dist/",
    ".git/"
  ],
  "metadata": {
    "lastUpdated": "2023-08-28",
    "maintainer": "doc-gen-mcp Team",
    "supportEmail": "support@example.com",
    "releaseNotes": "Version 1.0.4: Added README, improved categories, added Best Practices section"
  }
} 